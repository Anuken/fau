import gltypes
export gltypes

when defined(JS):
    import web/webgl as wrap
else:
    import sdl/sdlgl as wrap

#openGL wrapper functions

proc glActiveTexture*(texture: GLenum) {.inline.} = wrap.glActiveTexture(texture)
proc glAttachShader*(program: GLuint, shader: GLuint) {.inline.} = wrap.glAttachShader(program, shader)
proc glBindAttribLocation*(program: GLuint, index: GLuint, name: cstring) {.inline.} = wrap.glBindAttribLocation(program, index, name)
proc glBindBuffer*(target: GLenum, buffer: GLuint) {.inline.} = wrap.glBindBuffer(target, buffer)
proc glBindFramebuffer*(target: GLenum, framebuffer: GLuint) {.inline.} = wrap.glBindFramebuffer(target, framebuffer)
proc glBindRenderbuffer*(target: GLenum, renderbuffer: GLuint) {.inline.} = wrap.glBindRenderbuffer(target, renderbuffer)
proc glBindTexture*(target: GLenum, texture: GLuint) {.inline.} = wrap.glBindTexture(target, texture)
proc glBlendColor*(red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) {.inline.} = wrap.glBlendColor(red, green, blue, alpha)
proc glBlendEquation*(mode: GLenum) {.inline.} = wrap.glBlendEquation(mode)
proc glBlendEquationSeparate*(modeRGB: GLenum, modeAlpha: GLenum) {.inline.} = wrap.glBlendEquationSeparate(modeRGB, modeAlpha)
proc glBlendFunc*(sfactor: GLenum, dfactor: GLenum) {.inline.} = wrap.glBlendFunc(sfactor, dfactor)
proc glBlendFuncSeparate*(sfactorRGB: GLenum, dfactorRGB: GLenum, sfactorAlpha: GLenum, dfactorAlpha: GLenum) {.inline.} = wrap.glBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha)
proc glBufferData*(target: GLenum, size: GLsizeiptr, data: var openArray[GLfloat], usage: GLenum) {.inline.} = wrap.glBufferData(target, size, data, usage)
proc glBufferSubData*(target: GLenum, offset: GLintptr, size: GLsizeiptr, data: pointer) {.inline.} = wrap.glBufferSubData(target, offset, size, data)
proc glCheckFramebufferStatus*(target: GLenum): GLenum {.inline.} = wrap.glCheckFramebufferStatus(target)
proc glClear*(mask: GLbitfield) {.inline.} = wrap.glClear(mask)
proc glClearColor*(red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) {.inline.} = wrap.glClearColor(red, green, blue, alpha)
proc glClearDepthf*(d: GLfloat) {.inline.} = wrap.glClearDepthf(d)
proc glClearStencil*(s: GLint) {.inline.} = wrap.glClearStencil(s)
proc glColorMask*(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean) {.inline.} = wrap.glColorMask(red, green, blue, alpha)
proc glCompileShader*(shader: GLuint) {.inline.} = wrap.glCompileShader(shader)
proc glCompressedTexImage2D*(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, imageSize: GLsizei, data: pointer) {.inline.} = wrap.glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data)
proc glCompressedTexSubImage2D*(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: pointer) {.inline.} = wrap.glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data)
proc glCopyTexImage2D*(target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint) {.inline.} = wrap.glCopyTexImage2D(target, level, internalformat, x, y, width, height, border)
proc glCopyTexSubImage2D*(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) {.inline.} = wrap.glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height)
proc glCreateProgram*(): GLuint {.inline.} = wrap.glCreateProgram()
proc glCreateShader*(`type`: GLenum): GLuint {.inline.} = wrap.glCreateShader(`type`)
proc glCullFace*(mode: GLenum) {.inline.} = wrap.glCullFace(mode)
proc glDeleteBuffer*(buffer: GLuint) {.inline.} = wrap.glDeleteBuffer(buffer)
proc glDeleteFramebuffer*(framebuffer: GLuint) {.inline.} = wrap.glDeleteFramebuffer(framebuffer)
proc glDeleteProgram*(program: GLuint) {.inline.} = wrap.glDeleteProgram(program)
proc glDeleteRenderbuffer*(renderbuffer: GLuint) {.inline.} = wrap.glDeleteRenderbuffer(renderbuffer)
proc glDeleteShader*(shader: GLuint) {.inline.} = wrap.glDeleteShader(shader)
proc glDeleteTexture*(texture: GLuint) {.inline.} = wrap.glDeleteTexture(texture)
proc glDepthFunc*(`func`: GLenum) {.inline.} = wrap.glDepthFunc(`func`)
proc glDepthMask*(flag: GLboolean) {.inline.} = wrap.glDepthMask(flag)
proc glDepthRangef*(n: GLfloat, f: GLfloat) {.inline.} = wrap.glDepthRangef(n, f)
proc glDetachShader*(program: GLuint, shader: GLuint) {.inline.} = wrap.glDetachShader(program, shader)
proc glDisable*(cap: GLenum) {.inline.} = wrap.glDisable(cap)
proc glDisableVertexAttribArray*(index: GLuint) {.inline.} = wrap.glDisableVertexAttribArray(index)
proc glDrawArrays*(mode: GLenum, first: GLint, count: GLsizei) {.inline.} = wrap.glDrawArrays(mode, first, count)
proc glDrawElements*(mode: GLenum, count: GLsizei, `type`: GLenum, indices: pointer) {.inline.} = wrap.glDrawElements(mode, count, `type`, indices)
proc glEnable*(cap: GLenum) {.inline.} = wrap.glEnable(cap)
proc glEnableVertexAttribArray*(index: GLuint) {.inline.} = wrap.glEnableVertexAttribArray(index)
proc glFinish*() {.inline.} = wrap.glFinish()
proc glFramebufferRenderbuffer*(target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint) {.inline.} = wrap.glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer)
proc glFramebufferTexture2D*(target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint) {.inline.} = wrap.glFramebufferTexture2D(target, attachment, textarget, texture, level)
proc glFrontFace*(mode: GLenum) {.inline.} = wrap.glFrontFace(mode)
proc glGenBuffer*(): GLuint {.inline.} = wrap.glGenBuffer()
proc glGenerateMipmap*(target: GLenum) {.inline.} = wrap.glGenerateMipmap(target)
proc glGenFramebuffer*(): GLuint {.inline.} = wrap.glGenFramebuffer()
proc glGenRenderbuffer*(): GLuint {.inline.} = wrap.glGenRenderbuffer()
proc glGenTexture*(): GLuint {.inline.} = wrap.glGenTexture()
proc glGetActiveAttrib*(program: GLuint, index: GLuint, length: var GLsizei, size: var GLint, `type`: var GLenum, name: var string) {.inline.} = wrap.glGetActiveAttrib(program, index, length, size, `type`, name)
proc glGetActiveUniform*(program: GLuint, index: GLuint, length: var GLsizei, size: var GLint, `type`: var GLenum, name: var string) {.inline.} = wrap.glGetActiveUniform(program, index, length, size, `type`, name)
proc glGetAttribLocation*(program: GLuint, name: cstring): GLint {.inline.} = wrap.glGetAttribLocation(program, name)
proc glGetError*(): GLenum {.inline.} = wrap.glGetError()
proc glGetFloatv*(pname: GLenum): GLfloat {.inline.} = wrap.glGetFloatv(pname)
proc glGetIntegerv*(pname: GLenum): GLint {.inline.} = wrap.glGetIntegerv(pname)
proc glGetProgramiv*(program: GLuint, pname: GLenum): GLint {.inline.} = wrap.glGetProgramiv(program, pname)
proc glGetProgramInfoLog*(program: GLuint): string {.inline.} = wrap.glGetProgramInfoLog(program)
proc glGetShaderiv*(shader: GLuint, pname: GLenum): GLint {.inline.} = wrap.glGetShaderiv(shader, pname)
proc glGetShaderInfoLog*(shader: GLuint): string {.inline.} = wrap.glGetShaderInfoLog(shader)
proc glGetString*(name: GLenum): string {.inline.} = wrap.glGetString(name)
proc glGetUniformLocation*(program: GLuint, name: cstring): GLint {.inline.} = wrap.glGetUniformLocation(program, name)
proc glGetVertexAttribfv*(index: GLuint, pname: GLenum): GLfloat {.inline.} = wrap.glGetVertexAttribfv(index, pname)
proc glGetVertexAttribiv*(index: GLuint, pname: GLenum): GLint {.inline.} = wrap.glGetVertexAttribiv(index, pname)
proc glHint*(target: GLenum, mode: GLenum) {.inline.} = wrap.glHint(target, mode)
proc glIsBuffer*(buffer: GLuint): GLboolean {.inline.} = wrap.glIsBuffer(buffer)
proc glIsEnabled*(cap: GLenum): GLboolean {.inline.} = wrap.glIsEnabled(cap)
proc glIsFramebuffer*(framebuffer: GLuint): GLboolean {.inline.} = wrap.glIsFramebuffer(framebuffer)
proc glIsProgram*(program: GLuint): GLboolean {.inline.} = wrap.glIsProgram(program)
proc glIsRenderbuffer*(renderbuffer: GLuint): GLboolean {.inline.} = wrap.glIsRenderbuffer(renderbuffer)
proc glIsShader*(shader: GLuint): GLboolean {.inline.} = wrap.glIsShader(shader)
proc glIsTexture*(texture: GLuint): GLboolean {.inline.} = wrap.glIsTexture(texture)
proc glLineWidth*(width: GLfloat) {.inline.} = wrap.glLineWidth(width)
proc glLinkProgram*(program: GLuint) {.inline.} = wrap.glLinkProgram(program)
proc glPixelStorei*(pname: GLenum, param: GLint) {.inline.} = wrap.glPixelStorei(pname, param)
proc glPolygonOffset*(factor: GLfloat, units: GLfloat) {.inline.} = wrap.glPolygonOffset(factor, units)
proc glReadPixels*(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer) {.inline.} = wrap.glReadPixels(x, y, width, height, format, `type`, pixels)
proc glRenderbufferStorage*(target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei) {.inline.} = wrap.glRenderbufferStorage(target, internalformat, width, height)
proc glSampleCoverage*(value: GLfloat, invert: GLboolean) {.inline.} = wrap.glSampleCoverage(value, invert)
proc glScissor*(x: GLint, y: GLint, width: GLsizei, height: GLsizei) {.inline.} = wrap.glScissor(x, y, width, height)
proc glShaderSource*(shader: GLuint, source: string) {.inline.} = wrap.glShaderSource(shader, source)
proc glStencilFunc*(`func`: GLenum, `ref`: GLint, mask: GLuint) {.inline.} = wrap.glStencilFunc(`func`, `ref`, mask)
proc glStencilFuncSeparate*(face: GLenum, `func`: GLenum, `ref`: GLint, mask: GLuint) {.inline.} = wrap.glStencilFuncSeparate(face, `func`, `ref`, mask)
proc glStencilMask*(mask: GLuint) {.inline.} = wrap.glStencilMask(mask)
proc glStencilMaskSeparate*(face: GLenum, mask: GLuint) {.inline.} = wrap.glStencilMaskSeparate(face, mask)
proc glStencilOp*(fail: GLenum, zfail: GLenum, zpass: GLenum) {.inline.} = wrap.glStencilOp(fail, zfail, zpass)
proc glStencilOpSeparate*(face: GLenum, sfail: GLenum, dpfail: GLenum, dppass: GLenum) {.inline.} = wrap.glStencilOpSeparate(face, sfail, dpfail, dppass)
proc glTexImage2D*(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, `type`: GLenum, pixels: pointer) {.inline.} = wrap.glTexImage2D(target, level, internalformat, width, height, border, format, `type`, pixels)
proc glTexParameterf*(target: GLenum, pname: GLenum, param: GLfloat) {.inline.} = wrap.glTexParameterf(target, pname, param)
proc glTexParameterfv*(target: GLenum, pname: GLenum,): GLfloat {.inline.} = wrap.glTexParameterfv(target, pname)
proc glTexParameteri*(target: GLenum, pname: GLenum, param: GLint) {.inline.} = wrap.glTexParameteri(target, pname, param)
proc glTexParameteriv*(target: GLenum, pname: GLenum): GLint {.inline.} = wrap.glTexParameteriv(target, pname)
proc glTexSubImage2D*(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer) {.inline.} = wrap.glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, `type`, pixels)
proc glUniform1f*(location: GLint, v0: GLfloat) {.inline.} = wrap.glUniform1f(location, v0)
proc glUniform1fv*(location: GLint, count: GLsizei, value: openArray[GLfloat]) {.inline.} = wrap.glUniform1fv(location, count, value)
proc glUniform1i*(location: GLint, v0: GLint) {.inline.} = wrap.glUniform1i(location, v0)
proc glUniform1iv*(location: GLint, count: GLsizei, value: openArray[GLint]) {.inline.} = wrap.glUniform1iv(location, count, value)
proc glUniform2f*(location: GLint, v0: GLfloat, v1: GLfloat) {.inline.} = wrap.glUniform2f(location, v0, v1)
proc glUniform2fv*(location: GLint, count: GLsizei, value: openArray[GLfloat]) {.inline.} = wrap.glUniform2fv(location, count, value)
proc glUniform2i*(location: GLint, v0: GLint, v1: GLint) {.inline.} = wrap.glUniform2i(location, v0, v1)
proc glUniform2iv*(location: GLint, count: GLsizei, value: openArray[GLint]) {.inline.} = wrap.glUniform2iv(location, count, value)
proc glUniform3f*(location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) {.inline.} = wrap.glUniform3f(location, v0, v1, v2)
proc glUniform3fv*(location: GLint, count: GLsizei, value: openArray[GLfloat]) {.inline.} = wrap.glUniform3fv(location, count, value)
proc glUniform3i*(location: GLint, v0: GLint, v1: GLint, v2: GLint) {.inline.} = wrap.glUniform3i(location, v0, v1, v2)
proc glUniform3iv*(location: GLint, count: GLsizei, value: openArray[GLint]) {.inline.} = wrap.glUniform3iv(location, count, value)
proc glUniform4f*(location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat) {.inline.} = wrap.glUniform4f(location, v0, v1, v2, v3)
proc glUniform4fv*(location: GLint, count: GLsizei, value: openArray[GLfloat]) {.inline.} = wrap.glUniform4fv(location, count, value)
proc glUniform4i*(location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint) {.inline.} = wrap.glUniform4i(location, v0, v1, v2, v3)
proc glUniform4iv*(location: GLint, count: GLsizei, value: openArray[GLint]) {.inline.} = wrap.glUniform4iv(location, count, value)
proc glUniformMatrix2fv*(location: GLint, count: GLsizei, transpose: GLboolean, value: openArray[GLfloat]) {.inline.} = wrap.glUniformMatrix2fv(location, count, transpose, value)
proc glUniformMatrix3fv*(location: GLint, count: GLsizei, transpose: GLboolean, value: openArray[GLfloat]) {.inline.} = wrap.glUniformMatrix3fv(location, count, transpose, value)
proc glUniformMatrix4fv*(location: GLint, count: GLsizei, transpose: GLboolean, value: openArray[GLfloat]) {.inline.} = wrap.glUniformMatrix4fv(location, count, transpose, value)
proc glUseProgram*(program: GLuint) {.inline.} = wrap.glUseProgram(program)
proc glValidateProgram*(program: GLuint) {.inline.} = wrap.glValidateProgram(program)
proc glVertexAttrib1f*(index: GLuint, x: GLfloat) {.inline.} = wrap.glVertexAttrib1f(index, x)
proc glVertexAttrib1fv*(index: GLuint, v: openArray[GLfloat]) {.inline.} = wrap.glVertexAttrib1fv(index, v)
proc glVertexAttrib2f*(index: GLuint, x: GLfloat, y: GLfloat) {.inline.} = wrap.glVertexAttrib2f(index, x, y)
proc glVertexAttrib2fv*(index: GLuint, v: openArray[GLfloat]) {.inline.} = wrap.glVertexAttrib2fv(index, v)
proc glVertexAttrib3f*(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat) {.inline.} = wrap.glVertexAttrib3f(index, x, y, z)
proc glVertexAttrib3fv*(index: GLuint, v: openArray[GLfloat]) {.inline.} = wrap.glVertexAttrib3fv(index, v)
proc glVertexAttrib4f*(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat) {.inline.} = wrap.glVertexAttrib4f(index, x, y, z, w)
proc glVertexAttrib4fv*(index: GLuint, v: openArray[GLfloat]) {.inline.} = wrap.glVertexAttrib4fv(index, v)
proc glVertexAttribPointer*(index: GLuint, size: GLint, `type`: GLenum, normalized: GLboolean, stride: GLsizei, pointer: pointer) {.inline.} = wrap.glVertexAttribPointer(index, size, `type`, normalized, stride, pointer)
proc glViewport*(x: GLint, y: GLint, width: GLsizei, height: GLsizei) {.inline.} = wrap.glViewport(x, y, width, height)